<html>
<head>
  <title>Testt42</title>
  <script src="matter.js"></script>
  <script src="matter-attractors.js"></script>
</head>
<body>
<script>

// module aliases
var Engine = Matter.Engine,
    Render = Matter.Render,
    Body = Matter.Body,
    World = Matter.World,
    Constraint = Matter.Constraint,
    Composite = Matter.Composite,
    Composites = Matter.Composites,
    Events = Matter.Events,
    Vector = Matter.Vector,
    Bodies = Matter.Bodies;

var Chemistry = {};

// create an engine
var engine = Engine.create();
engine.world.gravity.y = 0;

// create a renderer
var render = Render.create({
    element: document.body,
    engine: engine,
    options: {
      wireframes: false
    }
});

/*
// create two boxes and a ground
particles = []
for (var i=0; i<200; i++) {
  x = Math.random()*700+50;
  y = Math.random()*500+50;
  var particle = Bodies.circle(x, y, 20, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
  Body.setVelocity(particle, {x: Math.random()*3-1.5, y: Math.random()*3-1.5});
  particles.push(particle);
}
*/


function stick_particle(particle) {
  particle.fixedPosition = {x: particle.position.x, y: particle.position.y};
  particle.frictionAir = 0.1;
  particle.sticked = true;
}

function create_crystal_particle(x, y, radius, options) {
  let particle = Bodies.circle(x, y, radius, options);
  particle.render.fillStyle = "white";
  stick_particle(particle);
  particle.formula = "Zn";
  particle.render.sprite.texture = 'zn.png';
  return particle;
}

var atomRadius = 20;
function create_h2o_molecule(x, y, options) {
  p = Vector.create(x, y);
  v = Vector.create(atomRadius, 0);
  v2 = Vector.rotate(v, 2.3);
  h1c = Vector.add(p, v);
  h2c = Vector.add(p, v2);
  var partO = Bodies.circle(p.x, p.y, atomRadius, options),
    partH1 = Bodies.circle(h1c.x, h1c.y, atomRadius/2, options),
    partH2 = Bodies.circle(h2c.x, h2c.y, atomRadius/2, options);

  partO.render.fillStyle = "white";
  partO.render.opacity = 0.1;
  partH1.render.fillStyle = "red";
  partH1.render.opacity = 0.1;
  partH2.render.fillStyle = "red";
  partH2.render.opacity = 0.1;

  var molecule = Body.create({
     parts: [partH1, partO, partH2], frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0
  });
  molecule.formula = "H2O";
  molecule.render.visible = true;
  molecule.render.opacity = 0.3;
  return molecule;
}

particles = []
for (var i=0; i<50; i++) {
  x = Math.random()*400+50;
  y = Math.random()*500+50;
  var particle = create_h2o_molecule(x, y, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
  Body.setVelocity(particle, {x: Math.random()*10-5, y: Math.random()*10-5});
  particles.push(particle);
}
World.add(engine.world, particles);

for (var x=0; x<5; x++) {
  for (var y=0; y<5; y++) {
    var cp = create_crystal_particle(x*atomRadius*2.2+500, y*atomRadius*2.2+100, atomRadius, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
    World.add(engine.world, cp);
  }
}

for (var i=0; i<10; i++) {
  x = Math.random()*400+50;
  y = Math.random()*500+50;
  var ball = Bodies.circle(x,y,atomRadius, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
  ball.render.sprite.texture =  'na+2.png';
  ball.formula = "Na+";
  ball.render.fillStyle = "blue";
  World.add(engine.world, ball);
}

var ground1 = Bodies.rectangle(600, 610, 1210, 60, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
var ground2 = Bodies.rectangle(600, -20, 1210, 60, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
var ground3 = Bodies.rectangle(-20, 300, 60, 610, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
var ground4 = Bodies.rectangle(1220, 300, 60, 610, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });

// add all of the bodies to the world
World.add(engine.world, [ground1, ground2, ground3, ground4]);

// run the engine
Engine.run(engine);

// run the renderer
Render.run(render);

var baseSpeed = 0;
function adjustE(ball) {
  if (baseSpeed == 0) baseSpeed = ball.speed;
  if (ball.speed != 0) {
    let speedMultiplier = baseSpeed / ball.speed 
    Body.setVelocity(
      ball, {
        x: ball.velocity.x * speedMultiplier,
        y: ball.velocity.y * speedMultiplier
      }
    );
  }
}

function kinetic_energy(body) {
  return body.speed*body.speed/2;
}


let maxForce = 0.01;
function calculate_force(body) {
  if (body.formula=="Na") {
     let force = {
          x: (700 - body.position.x) * 1e-6 * 3,
          y: (300 - body.position.y) * 1e-6 * 3,
        };
//     Body.applyForce(body, body.position, force);
  }
  if (body.sticked) {
    let d = Vector.sub(body.position, body.fixedPosition);
    let forceMagnitude = Vector.magnitude(d)*0.0001;
    if (forceMagnitude>maxForce) {
      forceMagnitude = maxForce;
    }
    let force = Vector.mult(Vector.neg(Vector.normalise(d)), forceMagnitude); 
    Body.applyForce(body, body.position, force);
  }
}

var prev_total_kinetic_energy = 0;
Events.on(engine, "beforeUpdate", (event) => {
  let total_kinetic_energy = 0;
  for (var body of event.source.world.bodies) {
    total_kinetic_energy += kinetic_energy(body);
    calculate_force(body);
  }
  if (prev_total_kinetic_energy==0) {
    prev_total_kinetic_energy = total_kinetic_energy;
  } else {
    energy_multiplier = prev_total_kinetic_energy/total_kinetic_energy;
    speed_multiplier = Math.sqrt(energy_multiplier);
    for (var body of event.source.world.bodies) {
      if (body.speed != 0) {
        Body.setVelocity(
          body, {
            x: body.velocity.x * speed_multiplier,
            y: body.velocity.y * speed_multiplier
          }
        );
      }
    }
  }
});

function isThisPair(a, b, aTest, bTest) {
  return ((a==aTest) && (b==bTest)) || ((a==bTest) && (b==aTest));
}

function waterClosenest(znParticle) {
  let p = znParticle.position;
  let closenent = 0;
  for (var body of engine.world.bodies) {
    if (body.formula=="H2O") {
      let dist = Vector.magnitude(Vector.sub(body.position, p))-2*atomRadius;
      if (dist<atomRadius) {
        closenent += 1;
      }
    }
  }
  return closenent;
}

function findZnParticleOnEdge() {
  let minWaterClosenest = Infinity;
  let bestZnParticle = null;
  for (var body of engine.world.bodies) {
    if (body.formula=="Zn") {
      let x = waterClosenest(body);
      if (minWaterClosenest>x) {
        minWaterClosenest = x;
        bestZnParticle = body;
      }
    }
  }
  return bestZnParticle;
}

Events.on(Chemistry, "onCollision_Na+_Zn", (event) => {
  let bodyNa = event.particleA;
  let bodyZn = event.particleB;
  let particleZn = findZnParticleOnEdge();
  particleZn.sticked = false;
  particleZn.frictionAir = 0;
  particleZn.formula = "Zn+";
  particleZn.render.sprite.texture = 'zn+.png';
  stick_particle(bodyNa);
  bodyNa.formula = "Na";
  bodyNa.render.sprite.texture =  'na.png';
  bodyNa.render.fillStyle = "lightblue";
});

Events.on(Chemistry, "onCollision_Na_Na+", (event) => {
  let bodyNaIon = event.particleB;
  let bodyNaAtom = event.particleA;
  stick_particle(bodyNaIon);
  bodyNaIon.formula = "Na";
  bodyNaIon.render.sprite.texture =  'na.png';
  bodyNaIon.render.fillStyle = "lightblue";
});

Events.on(engine, "collisionEnd", (event) => {
    for (var pair of event.pairs) {
      bodyA = pair.bodyA.parent;
      bodyB = pair.bodyB.parent;
//      console.log(bodyA.formula + " " + bodyB.formula);
      if (bodyA.formula<bodyB.formula) {
        Events.trigger(Chemistry, 'onCollision_'+bodyA.formula+'_'+bodyB.formula, { particleA: bodyA, particleB: bodyB });
      } else {
        Events.trigger(Chemistry, 'onCollision_'+bodyB.formula+'_'+bodyA.formula, { particleA: bodyB, particleB: bodyA });
      }
    }
});

function hide_water() {
  bodies_to_remove = [];
  for (var body of engine.world.bodies) {
    if (body.formula=="H2O") {
      bodies_to_remove.push(body);
    }
  }
  for (var body of bodies_to_remove) {
    World.remove(engine.world, body, true);  
  }
}
</script>
<button onclick="hide_water()">Hide water</button>
</body>
</html>
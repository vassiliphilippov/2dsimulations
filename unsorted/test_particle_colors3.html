<html>
<head>
  <title>Testt42</title>
  <script src="matter.js"></script>
  <script src="force.js"></script>
  <script src="zonemap.js"></script>
  <script src="chemistry.js"></script>
  <script src="chemistryparticles.json"></script>
  <script src="matter-attractors.js"></script>
</head>
<body>
<script>

// module aliases
var Engine = Matter.Engine,
    Render = Matter.Render,
    Body = Matter.Body,
    World = Matter.World,
    Constraint = Matter.Constraint,
    Composite = Matter.Composite,
    Composites = Matter.Composites,
    Events = Matter.Events,
    Vector = Matter.Vector,
    Bodies = Matter.Bodies;


function getFirstZoneRect(zoneData, rgb) {
  console.log("rgb = ", rgb);
  let rects = zoneData.zones[rgb];
  return rects[0];
}

// create an engine
var engine = Engine.create();
engine.world.gravity.y = 0;

// create a renderer
//todo: read width and height from map
var render = Matter.Render.create({
    element: document.body,
    engine: engine,
    options: {
      wireframes: false,
      width: 1172,
      height: 726
    }
});

/*
// create two boxes and a ground
particles = []
for (var i=0; i<200; i++) {
  x = Math.random()*700+50;
  y = Math.random()*500+50;
  var particle = Bodies.circle(x, y, 20, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
  Body.setVelocity(particle, {x: Math.random()*3-1.5, y: Math.random()*3-1.5});
  particles.push(particle);
}
*/


function stick_particle(particle) {
  particle.fixedPosition = {x: particle.position.x, y: particle.position.y};
  particle.frictionAir = 0.1;
  particle.sticked = true;
}

function create_crystal_particle(x, y, radius, options) {
  let particle = Bodies.circle(x, y, radius, options);
  particle.render.fillStyle = "white";
  stick_particle(particle);
  particle.formula = "Zn";
  particle.render.sprite.texture = 'zn.png';
  return particle;
}

var atomRadius = 20;
function create_h2o_molecule(x, y, options) {
  p = Vector.create(x, y);
  v = Vector.create(atomRadius, 0);
  v2 = Vector.rotate(v, 2.3);
  h1c = Vector.add(p, v);
  h2c = Vector.add(p, v2);
  var partO = Bodies.circle(p.x, p.y, atomRadius, options),
    partH1 = Bodies.circle(h1c.x, h1c.y, atomRadius/2, options),
    partH2 = Bodies.circle(h2c.x, h2c.y, atomRadius/2, options);

  partO.render.fillStyle = "white";
  partO.render.opacity = 0.1;
  partH1.render.fillStyle = "red";
  partH1.render.opacity = 0.1;
  partH2.render.fillStyle = "red";
  partH2.render.opacity = 0.1;

  var molecule = Body.create({
     parts: [partH1, partO, partH2], frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0
  });
  molecule.formula = "H2O";
  molecule.render.visible = true;
  molecule.render.opacity = 0.3;
  return molecule;
}

let zoneWaterColor = [255, 255, 255];
let zoneBorder1Color = [1, 0, 0];
let zoneBorder2Color = [100, 0, 0];
let zoneBorder3Color = [0, 100, 0];
let zoneBorder4Color = [0, 0, 100];
let zoneZnColor = [237, 28, 36];

let particleColors = {};
particleColors[[0, 254, 0]] = "Sn2+";
particleColors[[254, 0, 0]] = "Cl-";

/*let particleColors = {
  [0, 254, 0]: "Sn2+",
  : "Cl-"
};*/

ZoneMap.load("map4.png", function (zoneMap) {
  console.log(zoneMap);
  World.add(engine.world, Chemistry.createMappedParticles(zoneMap));

/*
  //Usage examples
  ZoneMap.spawnSeries(zoneMap, [0, 254, 0], function(x, y, width, height) {
    let ball = Bodies.circle(x,y,atomRadius, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
    ball.render.sprite.texture =  'na+2.png';
    ball.formula = "Na+";
    ball.render.fillStyle = "blue";
    World.add(engine.world, ball);
  });

  ZoneMap.spawnRandom(zoneMap, [63, 72, 204], 100, function(x, y) {
    var particle = create_h2o_molecule(x, y, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
    Body.setVelocity(particle, {x: Math.random()*10-5, y: Math.random()*10-5});
    World.add(engine.world, particle);
  });


  ZoneMap.spawnLattice(zoneMap, zoneZnColor, atomRadius*2.2, atomRadius*2.2, function(x, y) {
    var cp = create_crystal_particle(x, y, atomRadius, { frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0 });
    World.add(engine.world, cp);
  });
*/

r1 = getFirstZoneRect(zoneMap, zoneBorder1Color);
r2 = getFirstZoneRect(zoneMap, zoneBorder2Color);
r3 = getFirstZoneRect(zoneMap, zoneBorder3Color);
r4 = getFirstZoneRect(zoneMap, zoneBorder4Color);
var ground1 = Bodies.rectangle((r1.x1+r1.x2)/2, (r1.y1+r1.y2)/2, r1.x2-r1.x1, r1.y2-r1.y1, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0, render: {fillStyle: "red"} });
var ground2 = Bodies.rectangle((r2.x1+r2.x2)/2, (r2.y1+r2.y2)/2, r2.x2-r2.x1, r2.y2-r2.y1, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0, render: {fillStyle: "green"} });
ground2.plugin.force = {forces: {red: {charge: 0.2, type: "gravity"}}};
var ground3 = Bodies.rectangle((r3.x1+r3.x2)/2, (r3.y1+r3.y2)/2, r3.x2-r3.x1, r3.y2-r3.y1, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0, render: {fillStyle: "blue"} });
var ground4 = Bodies.rectangle((r4.x1+r4.x2)/2, (r4.y1+r4.y2)/2, r4.x2-r4.x1, r4.y2-r4.y1, { isStatic: true, frictionAir: 0, friction: 0, restitution: 1, frictionStatic: 0, render: {fillStyle: "yellow"} });
World.add(engine.world, [ground1, ground2, ground3, ground4]);

// run the engine
Engine.run(engine);

// run the renderer
Render.run(render);

Force.init(engine);

});

function kinetic_energy(body) {
  return body.speed*body.speed/2;
}


var prev_total_kinetic_energy = 0;
Events.on(engine, "beforeUpdate", (event) => {
  let total_kinetic_energy = 0;
  for (var body of event.source.world.bodies) {
    total_kinetic_energy += kinetic_energy(body);
  }
  if (prev_total_kinetic_energy==0) {
    prev_total_kinetic_energy = total_kinetic_energy;
  } else {
    energy_multiplier = prev_total_kinetic_energy/total_kinetic_energy;
    speed_multiplier = Math.sqrt(energy_multiplier);
    for (var body of event.source.world.bodies) {
      if (body.speed != 0) {
        Body.setVelocity(
          body, {
            x: body.velocity.x * speed_multiplier,
            y: body.velocity.y * speed_multiplier
          }
        );
      }
    }
  }
});

function isThisPair(a, b, aTest, bTest) {
  return ((a==aTest) && (b==bTest)) || ((a==bTest) && (b==aTest));
}

function waterClosenest(znParticle) {
  let p = znParticle.position;
  let closenent = 0;
  for (var body of engine.world.bodies) {
    if (body.formula=="H2O") {
      let dist = Vector.magnitude(Vector.sub(body.position, p))-2*atomRadius;
      if (dist<atomRadius) {
        closenent += 1;
      }
    }
  }
  return closenent;
}

function findZnParticleOnEdge() {
  let minWaterClosenest = Infinity;
  let bestZnParticle = null;
  for (var body of engine.world.bodies) {
    if (body.formula=="Zn") {
      let x = waterClosenest(body);
      if (minWaterClosenest>x) {
        minWaterClosenest = x;
        bestZnParticle = body;
      }
    }
  }
  return bestZnParticle;
}

Events.on(Chemistry, "onCollision_Na+_Zn", (event) => {
  let bodyNa = event.particleA;
  let bodyZn = event.particleB;
  let particleZn = findZnParticleOnEdge();
  particleZn.sticked = false;
  particleZn.frictionAir = 0;
  particleZn.formula = "Zn+";
  particleZn.render.sprite.texture = 'zn+.png';
  stick_particle(bodyNa);
  bodyNa.formula = "Na";
  bodyNa.render.sprite.texture =  'na.png';
  bodyNa.render.fillStyle = "lightblue";
});

Events.on(Chemistry, "onCollision_Na_Na+", (event) => {
  let bodyNaIon = event.particleB;
  let bodyNaAtom = event.particleA;
  stick_particle(bodyNaIon);
  bodyNaIon.formula = "Na";
  bodyNaIon.render.sprite.texture =  'na.png';
  bodyNaIon.render.fillStyle = "lightblue";
});

Events.on(engine, "collisionEnd", (event) => {
    for (var pair of event.pairs) {
      bodyA = pair.bodyA.parent;
      bodyB = pair.bodyB.parent;
//      console.log(bodyA.formula + " " + bodyB.formula);
      if (bodyA.formula<bodyB.formula) {
        Events.trigger(Chemistry, 'onCollision_'+bodyA.formula+'_'+bodyB.formula, { particleA: bodyA, particleB: bodyB });
      } else {
        Events.trigger(Chemistry, 'onCollision_'+bodyB.formula+'_'+bodyA.formula, { particleA: bodyB, particleB: bodyA });
      }
    }
});

function hide_water() {
  bodies_to_remove = [];
  for (var body of engine.world.bodies) {
    if (body.formula=="H2O") {
      bodies_to_remove.push(body);
    }
  }
  for (var body of bodies_to_remove) {
    World.remove(engine.world, body, true);  
  }
}
</script>
<button onclick="hide_water()">Hide water</button>
</body>
</html>
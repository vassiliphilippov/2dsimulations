<html>
<script>

class Stack {
  constructor(){
    this.data = [];
    this.top = 0;
  }
  push(element) {
    this.data[this.top] = element;
    this.top = this.top + 1;
  }
  pop() {
    this.top = this.top -1;
    return this.data.pop(); 
  }
  hasMoreElements() {
    return this.top !== 0;
  }
}

function loadMapImage(mapImageUrl, onload) {
  let image = new Image();
  image.onload = function () {
    let canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    canvas.getContext('2d').drawImage(image, 0, 0, image.width, image.height);
    imageData = canvas.getContext('2d').getImageData(0, 0, image.width, image.height); 
    mapImageData = parseMapImage(imageData, image.width, image.height);
    onload(mapImageData);
  }
  image.src = mapImageUrl;
}

function parseMapImage(imageData, width, height) {
  let checked = Array(width*height).fill(false);
  let colorZones = {}
  for (var y=0; y<height; y++) {
    for (var x=0; x<width; x++) {
      if (!checked[y*width+x]) {
        let rgb = getImageDataPoint(imageData, x, y);
        rect = findSameColorConnected(imageData, checked, x, y);
        if (!colorZones[rgb]) colorZones[rgb] = [];
        colorZones[rgb].push(rect);
      }
    }
  }
  return {imageData: imageData.data, width: width, height: height, zones: colorZones};
}

function findSameColorConnected(imageData, checked, startX, startY) {
  let width = imageData.width;
  let height = imageData.height;
  let rgb = getImageDataPoint(imageData, startX, startY);
  let minX = startX;
  let maxX = startX;
  let minY = startY;
  let maxY = startY;
  let recstack = new Stack(); 
  recstack.push(startX+startY*width);
  while (recstack.hasMoreElements()) {
    let i = recstack.pop();     

    //if out of border then skip
    let x = i % width;
    let y = Math.floor(i/width);
    if (x<0 || y<0 || x>=width || y>=height) continue;

    //if this point was already checked then skip it
    if (checked[i]) continue;

    //if not the same color then skip
    let crgb = getImageDataPoint(imageData, x, y);
    if (rgb[0]!=crgb[0] || rgb[1]!=crgb[1] || rgb[2]!=crgb[2]) continue;

    //update the boundary rect
    if (x<minX) minX=x;
    if (x>maxX) maxX=x;
    if (y<minY) minY=y;
    if (y>maxY) maxY=y;

    //mark this point as checed
    checked[i] = true;

    //and check all the neighbours
    recstack.push((x+1) + (y)*width);
    recstack.push((x-1) + (y)*width);
    recstack.push((x) + (y+1)*width);
    recstack.push((x) + (y-1)*width);
  } 
  return [minX, minY, maxX, maxY];
}

function getImageDataPoint(imageData, x, y) {
  let i = (x+y*imageData.width)*4;
  return [imageData.data[i], imageData.data[i+1], imageData.data[i+2]];
}

function isZoneFound(zones, rgb) {
  console.log(zones);
  return (rgb in zones);
}

function getFirstZoneCenter(zones, rgb) {
  let rects = zones[rgb];
  let rect = rects[0];
  return [ Math.floor((rect[0]+rect[2])/2) , Math.floor((rect[1]+rect[3])/2) ];
}

function getZoneCenters(zones, rgb) {
  if (!isZoneFound(zones, rgb)) console.log("error color not found ", rgb);
  let rects = zones[rgb];
  let centers = [];
  for (rect of rects) {
    centers.push( [ Math.floor((rect[0]+rect[2])/2) , Math.floor((rect[1]+rect[3])/2) ] );
  }
  return centers;
}

loadMapImage("map.png", function (zonesData) {
  console.log(zonesData);
  console.log(getZoneCenters(zonesData.zones, [0, 255, 0]));
});

</script>
</html>
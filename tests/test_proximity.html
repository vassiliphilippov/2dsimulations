<html>
<head>
  <title>Testt42</title>
  <script src="matter.js"></script>
  <script src="force.js"></script>
  <script src="zonemap.js"></script>
  <script src="debug.js"></script>
  <script src="chemistryparticles.json"></script>
  <script src="periodictable.json"></script>
  <script src="atomcolors.json"></script>
  <script src="chemistry.js"></script>
  <script src="proximity.js"></script>
  <script src="particles.js"></script>
  <script src="background.js"></script>
  <script src="temperature.js"></script>
  <script src="chemistryrender.js"></script>
</head>
<body>
<script>

ZoneMap.load("map6.png", function (zoneMap) {
    var engine = Matter.Engine.create();
    var render = ChemistryRender.create({element: document.body, engine: engine, options: {width: zoneMap.width, height: zoneMap.height}});
    Background.setBackground(engine.world, 'bkg.png', zoneMap.width, zoneMap.height);

    ZoneMap.spawnRandom(zoneMap, [255,255,255], 10, (x, y) => {
        Matter.World.add(engine.world, Chemistry.createParticleByStruct("H2O", waterStruct, x, y));
    });

    Matter.World.add(engine.world, Chemistry.createMappedBodies(zoneMap));
    let pl = new ParticleList(engine);
    pl.setChemistryOptions({temperature: 40});
    pl.setOptions({plugin: {proximity: {levels: [10]}}});
    new ParticleList(engine).formula("H2O").setChemistryOptions({temperature: 50});

    //Fix that temperature only works after animation ends
    //Todo: make a separate object/file for animations
    let a = new AttractorList(engine).zoneMapColor("0,162,3").first();
    let attractors = new AttractorList(engine).zoneMapColor("0,100,3").toArray();
    let pathAttractors = [a];
    let prevPosition = a.position;
    while (attractors.length>0) {
        let iMin = 0;
        let minDist = Infinity;
        for (let i=0; i<attractors.length; i++) {
            let dist = Matter.Vector.magnitude(Matter.Vector.sub(prevPosition, attractors[i].position));
            if (dist<minDist) {
                minDist = dist;
                iMin = i;
            }
        }
        prevPosition = attractors[iMin].position;
        pathAttractors.push(attractors[iMin]);
        attractors.splice(iMin, 1);
    }

//    Force.addAttraction(pl.formula("Na+").first(), a, 0.1);

    pl.formula("Na+").forEach(p => {
        p.plugin.animation = {
            wayPoints: pathAttractors,
            currentWayPointIndex: 0,
            attractionLevel: 1
        };
        Force.addAttraction(p, a, 1);
        Matter.Events.on(p, "comeClose", event => {
            let body = event.body;
            if (body.plugin.animation) {
                let animation = body.plugin.animation;
                let target = animation.wayPoints[animation.currentWayPointIndex];
                if (event.anotherBody==target) {
                    Force.removeAttraction(body, target);
                    animation.currentWayPointIndex += 1;
                    if (animation.currentWayPointIndex < animation.wayPoints.length) {
                        let nextTarget = animation.wayPoints[animation.currentWayPointIndex];
                        Force.addAttraction(body, nextTarget, animation.attractionLevel);
                    } else {
                        delete body.plugin.animation;
                    }
                }
            }
        }); 
    });

    engine.world.gravity.y = 0;
    Debug.init(engine);
    Force.init(engine);
    Temperature.init(engine);
    Matter.Engine.run(engine);
    ChemistryRender.run(render);
    //Todo: decide when run and when init

});

</script>
</body>
</html>